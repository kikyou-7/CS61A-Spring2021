(define (filter-lst fn lst) 
	(define (cmb lst val)
		(if (fn val) 
			(append lst (list val))
			lst	
		)
	)
	(define (sol lst cur)
		(if (null? lst) 
			cur
			(sol (cdr lst) (cmb cur (car lst)) )
		) 
	)
	(sol lst nil)
)

; ;; Tests
(define (even? x) (= (modulo x 2) 0))

(filter-lst even? '(0 1 1 2 3 5 8))

; expect (0 2 8)
(define (interleave first second) 
	(define (cmb lst val)		 
		(append lst (list val))
	)
	(define (sol l1 l2 cur f) 
		(if (and (null? l1) (null? l2)) 
			cur	
			(if (= f 0)
				(if (null? l1)
					(sol l1 l2 cur 1)
					(sol (cdr l1) l2 (cmb cur (car l1)) 1)
				)
				(if (null? l2)
					(sol l1 l2 cur 0)
					(sol l1 (cdr l2) (cmb cur (car l2)) 0)
				)
			)
		)
	)
	(sol first second '() 0)
)

(interleave (list 1 5 3) (list 2 4 6))

; expect (1 2 5 4 3 6)
(interleave (list 1 3 5) nil)

; expect (1 3 5)
(interleave (list 1 3 5) (list 2 4))

; expect (1 2 3 4 5)
(define (accumulate combiner start n term)
	(define (sol cur n)
		(if (= 1 n) 
			(combiner cur (term 1)) 
			(sol (combiner cur (term n)) (- n 1) )
		)
	)
	(sol start n)
)

(define (without-duplicates lst) 
	(define (filter-lst find lst) 
		(define (cmb lst val)
			(if (find lst val) 
				lst
				(append lst (list val))
			)
		)
		(define (sol lst cur)
			(if (null? lst) 
				cur
				(sol (cdr lst) (cmb cur (car lst)) )
			) 
		)
		(sol lst nil)
	)
	(define (find lst val)
		(if (null? lst) 
			#f 
			(if (= val (car lst)) 
				#t 
				(find (cdr lst) val)
			)
		)
	)
	(filter-lst find lst)
)
